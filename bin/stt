#!/usr/bin/php
<?php
# (c) Kevin Sandom 2020 - GPLv3. See LICENSE for details.

if (!isset($argv[2]))
{
    displayHelp();
    die ("\n\nNeed more input. So I displayed help, and am now exiting.\n");
}

if ($argv[1] == '--help')
{
    displayHelp();
    exit(0);
}

$file_in=$argv[1];
$destinationTime=$argv[2];
$file_out='ql-out.srt';

$contents = file_get_contents($file_in);
$lines=explode("\n", $contents);
$output=array();


# Destination time
$creditsTime=(isset($argv[3]))?$argv[3]:33; # Seconds

function displayHelp()
{
    echo "stt - SubTitle Transpose
    (c) Kevin Sandom 2020 - GPLv3. See LICENSE for details.
    Transposes subtitles when the subtitle timings don't match the video. There are many reasons why this can happen, and this will only cater to some of them. YMMV.
    
    It takes the latest subtitle entry, and assumes it's the end of the video. Entering the videoLength gives it enough information to reposition everything between the start to the the end to be until the videoLength value instead.
    
    However there may be some time after the last subtitle before the video ends, while the credits roll. You can specify this with creditsLengthInSeconds. It's assumed to be 33 seconds if it's not specified. Why 33? Because that's what was convenient when I wrote this.
    
    Syntax
        stt inputSubtitleFile videoLength [creditsLengthInSeconds] > outputFileName.srt
    
    Examples
        # Take input.srt, specify that it ends at 00:46:13, and create output.srt as the result.
        stt input.srt 00:46:13 > output.srt
        
        # Same, but using the .SRT timestamp format.
        stt input.srt 00:46:13,00 > output.srt
        
        # Same, but specify that there are 60 seconds of credits after the last subtitles.
        stt input.srt 00:46:13 60 > output.srt\n";
}

function timeStampToSeconds($timeStamp)
{
    $parts=explode(':', $timeStamp);
    
    $parts[2]=implode('.', explode(',', $parts[2]));
    
    $resultParts=array();
    $resultParts[0]=$parts[0]*3600;
    $resultParts[1]=$parts[1]*60;
    $resultParts[2]=trim($parts[2]);
    
    $result=$resultParts[0]+$resultParts[1]+$resultParts[2];
    return $result;
}

function secondsToTimestamp($seconds)
{
    $hours=intval($seconds/3600);
    $seconds=$seconds-($hours*3600);
    $hoursPad=str_pad($hours, 2, '0', STR_PAD_LEFT);
    
    $minutes=intval($seconds/60);
    $seconds=round($seconds-($minutes*60), 3);
    $minutesPad=str_pad($minutes, 2, '0', STR_PAD_LEFT);
    
    if (strpos($seconds, '.'))
    {
        $secondsParts=explode('.', $seconds);
    }
    else
    {
        $secondsParts=explode(',', $seconds);
    }
    
    if (!isset($secondsParts[1])) $secondsParts[1]='000';
    
    $secondsParts[0]=str_pad($secondsParts[0], 2, '0', STR_PAD_LEFT);
    $secondsParts[1]=str_pad($secondsParts[1], 3, '0', STR_PAD_RIGHT);
    $secondsPad=implode(',', $secondsParts);
    
    $result="$hoursPad:$minutesPad:$secondsPad";
    return $result;
}

function lineToTimestamps($line)
{
    return explode(' --> ', $line);
}

function timestampsToTimes($timestamps)
{
    foreach ($timestamps as $key=>&$timeStamp)
    {
        $timeStamp=timeStampToSeconds($timeStamp);
    }
    
    return $timestamps;
}

function timesToTimestamps($times)
{
    foreach ($times as $key=>&$time)
    {
        $time=secondsToTimestamp($time);
    }
    
    return $times;
}

function transposeTime($inputTime, $fromEnd, $toEnd)
{
    return $inputTime/$fromEnd*$toEnd;
}

# Find out the largest time that we have.
$largestFromTime=0;
foreach ($lines as $line)
{
    if ($result=strpos($line, '-->') !== false)
    {
        $times=timestampsToTimes(lineToTimestamps($line));
        if ($times[1]>$largestFromTime) $largestFromTime=$times[1];
    }
}

# Convert the destinationTime to something we can use.
$toTime=timeStampToSeconds($destinationTime)-$creditsTime;


foreach ($lines as $line)
{
    if ($result=strpos($line, '-->') !== false)
    {
        $times=timestampsToTimes(lineToTimestamps($line));
        $times[0]=transposeTime($times[0], $largestFromTime, $toTime);
        $times[1]=transposeTime($times[1], $largestFromTime, $toTime);
        
        $timestamps=timesToTimestamps($times);
        
        echo "{$timestamps[0]} --> {$timestamps[1]}\n";
    }
    else
    {
        echo "$line\n";
    }
}

?>
